# Начнём изучение Lisp!
## Введение:
Напишем тривиальное a+b:

    (+ 2 3) ; 5
Сигнатура функций в Lisp: **(имя_функции  аргумент_1  аргумент_2 ...)**

Аргументами функции могут выступать другие функции:

    (* (+ 2 2) (- 11 1)) ; 40
Напишем свою функцию:

    (defun имя_функции(аргумент_1  аргумент_2 ...)
      (функция_1
        (функция_2
        ...
        )))
Напишем функцию увеличения числа на 1:

    (defun inc(chislo)(+ chislo 1))
Рассмотрим предикат, как и в алгебре логики, это функция, которая возвращает правду или ложь, соответственно T и NIL. Любой объект отличный от NIL интерпретируется как T. Обычно предикаты заканчиваются на букву p:

    (defun isdigitp(chislo)
        (if(< chislo 10) chislo NIL)
        )
Таким образом наш предикат возвращает само число, если она цифра, и NIL в обратном случае.
## Типы данных Lisp:
В Lisp существует только два типа переменных: **атомы** и **списки**. **Атомы** — неделимые объекты, все остальные объекты представлены в виде списков. Таким образом **списки** являются универсальным объектом, который может хранить в себе как код, так и значения, следовательно может объединять в себе множество элементов различной сложности. В языке Lisp **объект**, а **не переменная** имеет привычный нам тип данных. Конечно можно ввести некоторые ограничения на переменную, но их можно обойти. **Объект** в Lisp может принадлежать нескольким типам данных, поэтому очень интересно узнать, а принадлежит ли данный объект этому типу данных. Если объект принадлежит всем типам данных, то он обозначается как T(true), если не принадлежит ни к одному, то NIL(false). Существует также тип **common**, который представляет из себя множество типов, которые обязательны для любой реализации Lisp. Для того, чтобы проверить относится ли данный тип данных к common используют предикат commonp. Теперь рассмотрим базовые **типы данных**:

* **Числа** — обычные числа целые и вещественные, переходят друг в друга при понятных условиях, также возможна работа и с комплексными числами
* **Буквы** — обычные печатные символы текста
* **Символы** — отличие символов от букв в области применения, используются для именования функций и переменных.
* **Списки** — некоторая последовательность данных, пустой список эквивалентен NIL.
* **Массивы** — набор однотипных данных, к которым можно обращаться по индексу. Lisp поддерживает любое положительное количество измерений и любую целочисленную индексацию.
* **Хэш-таблицы** — множество пар ключ — значение, к которым возможен доступ через ключ
* **Таблицы чтения** — служат для модификации работы анализаторов Lisp.
* **Пакеты** — как и в любом другом языке программированию служат для разграничения пространства имен, иными словами служат для устранения конфликтов с именованием переменных
* **Путевые имена** — имена файлов
* **Потоки** — некоторые интерфейсы для доступа(чтения) или вывода(записи) информации
* **Случайные ячейки** — ячейки, которые использует генератор случайных чисел
* **Структуры** — пользовательский тип данных, который представляет из себя некоторый набор базовых типов
* **Функции** — некоторый набор команд(функций), который возвращает значение
* **Сигналы** — специальный тип данных, который используют для управлением ходом исполнения программы
* **Классы** — сложный объект в Lisp, который задает поведение для своих экземпляров.
* **Методы** — функции без аргументов, которые находятся в классе.
* **Обобщенные функции** — функция, которая в своей реализации содержит некоторый набор функций

К атомам в языке Lisp относят цифры и символы. Напишем проверку этого факта:

        (defun isatomp(atom)
    (or (numberp atom) (symbolp atom)))
Теперь проверим нашу функцию:

    (isatomp 1)
    T
    (isatomp 'symbol)
    T
## Символы в Lisp:
**Основное назначение символов в Lisp это использование их в качестве переменных**. Им может стать любая последовательность печатных символов, кроме кавычек и пробела. **В языке Lisp регистр символов не учитывается**:

    symbol
    Symbol
    SymboL ; идентичны
Так как в качестве символов можно использовать достаточно большой набор значений, то они могут принимать достаточно специфичный вид:

    symbol.io ; символ с точкой
    symbol..io ; две точки подряд запрещены
    symbol/io/lisp ; символ с косой чертой
    100500+ ; символ из чисел и знака плюс
    +100500 ; уже число
Таким образом символ является аналогом переменных в других языках. Он сам по себе не имеет никакого типа, но объект, который лежит по данному символу имеет тип. Любой символ имеет печатное имя, с помощью которого вы сможете обращаться к нему. Кроме этого, в языке Lisp есть механизмы, которые позволяют использовать уникальные имена для переменных. Таким образом символы разделены по пакетам, которые позволяют лучше их структурировать. Кроме этого существует возможность манипулировать набором свойств символа с помощью **plist**. В нем на чётных местах расположены названия свойств, а на нечетных значения. **Так как символ это название переменной, то лучше все таки называть их осмысленно.**

**Не нужно называть символом зарезервированные слова.** Например, нельзя использовать t в качестве символа, так как компилятор выдаст ошибку, t - это константа, и ее нельзя использовать в качестве переменной.

## Списки в Lisp:
Списки в языке программирования LISP состоят из CONS ячеек, где каждая ячейка состоит из двух частей:

* CAR — первая часть ячейки, определяет значение в текущей ячейке
* CDR — ссылка на следующую cons ячейку

Таким образом, если у вас есть список (a b c), то CAR вернет первый элемент в списке - a. А функция CDR вернет на том же списке (b c). Если мы применим функции CAR и CDR на списке ((a b) c), то CAR — (a b), а CDR — c. Пустой список обозначается как NIL. NIL имеет двойственную природу, он единственный элемент в LISP является и списком и атомом. Таким образом становится понятно, что последний элемент списка является NIL. Так LISP понимает, что ваш список закончен. Кроме этого, вы можете явно указать последний элемент, таким образом CDR часть последнего элемента будет указывать на другой элемент, который может и не быть CONS ячейкой.

Пример:

    (car '(a b c)) ; a
    (car '((a b) c)) ; (a b)
    (cdr '(a b c) ; (b c)
    (cdr '((a b) c)) ; c
Как вы могли заметить из примера, для того, чтобы задать список, который не содержит первым элементом функцию необходимо применять одинарную кавычку. Функция CONS формирует список из двух аргументов: первый аргумент данная функция использует как CAR — часть новой CONS ячейки, а вторую как CDR. Пример использования функции CONS:

    (cons 1 '(2 3)) ; (1 2 3)
    (cons '(2 3) 1) ; ((2 3) . 1)
Таким образом мы видим, что последовательность аргументов в CONS очень важна и ошибка в ней может привести к не очень интересным результатам. Что же означает точка после списка (2 3)? Она означает что вывели на экран CONS ячейку, у которой CDR ссылается на объект отличный от другой CONS ячейки, и он выводится на экран через точку. Теперь мне хотелось бы вам рассказать про дополнительные функции работы со списками. Очень интересное формирование имен происходит в языке LISP. Вместо того, чтобы вызвать функция CAR, а затем CDR, можно вызвать функцию CADR. Данный способ именования функций встретится вам в языке LISP еще не один раз. Очень полезной функцией для работы со списками является:

    (nth i list) ; возвращает i-ый элемент в списке
    (nth 0 '(1 2 3)) ; 1
    (nth 1 '(1 2 3)) ; 2
    (nth 2 '(1 2 3)) ; 3
Отсчёт начинается с 0.

Таким образом мы задаём список:
  
    (set 'list '(1 2 3 4 5)) ; list = (1 2 3 4 5)
